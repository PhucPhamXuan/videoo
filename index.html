<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>üöÄ T·ªëi ∆∞u Video Player t·ª´ PNG ch·ª©a TS</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background: #f0f0f0;
    }
    .container {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    video {
      width: 100%;
      max-width: 640px;
      border-radius: 8px;
    }
    .progress-bar {
      width: 100%;
      height: 20px;
      background: #e0e0e0;
      border-radius: 10px;
      overflow: hidden;
      margin: 10px 0;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(45deg, #4CAF50, #2196F3);
      transition: width 0.3s ease;
      border-radius: 10px;
    }
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin: 15px 0;
    }
    .stat-item {
      background: #f8f9fa;
      padding: 10px;
      border-radius: 5px;
      text-align: center;
      border-left: 4px solid #2196F3;
    }
    .controls {
      margin: 15px 0;
    }
    button {
      background: #2196F3;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      margin-right: 10px;
      font-size: 14px;
    }
    button:hover {
      background: #1976D2;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .log {
      background: #f5f5f5;
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #ddd;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>üöÄ T·ªëi ∆∞u Video Player t·ª´ PNG ch·ª©a TS</h2>
    
    <div class="controls">
      <button id="loadBtn">üì• T·∫£i Video (Ch·∫≠m & ·ªîn ƒë·ªãnh)</button>
      <button id="pauseBtn" disabled>‚è∏Ô∏è T·∫°m d·ª´ng</button>
      <button id="resumeBtn" disabled>‚ñ∂Ô∏è Ti·∫øp t·ª•c</button>
      <button id="clearBtn">üóëÔ∏è X√≥a cache</button>
    </div>

    <div class="progress-bar">
      <div class="progress-fill" id="progressFill" style="width: 0%"></div>
    </div>

    <div class="stats">
      <div class="stat-item">
        <strong>Ti·∫øn ƒë·ªô</strong><br>
        <span id="progressText">0/0</span>
      </div>
      <div class="stat-item">
        <strong>T·ªëc ƒë·ªô</strong><br>
        <span id="speedText">0 MB/s</span>
      </div>
      <div class="stat-item">
        <strong>Th·ªùi gian</strong><br>
        <span id="timeText">--:--</span>
      </div>
      <div class="stat-item">
        <strong>Dung l∆∞·ª£ng</strong><br>
        <span id="sizeText">0 MB</span>
      </div>
    </div>

    <video id="player" controls style="display: none;"></video>
    
    <div class="log" id="log">üìã Nh·∫≠t k√Ω ho·∫°t ƒë·ªông s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y...</div>
  </div>

  <!-- ffmpeg.wasm (UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.10.1/dist/ffmpeg.min.js"></script>

  <script>
    const { createFFmpeg, fetchFile } = window.FFmpeg;
    const ffmpeg = createFFmpeg({ 
      log: true,
      corePath: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.10.0/dist/ffmpeg-core.js'
    });

    const BASE_URL = "https://raw.githubusercontent.com/phucphamxuan/video/main/";
    const HEADER_FILE = "header.png";
    const TOTAL_SEGMENTS = 521;
    const MAX_CONCURRENT = 2; // Ch·ªâ 2 connections ƒë·ªìng th·ªùi
    const CHUNK_SIZE = 50; // X·ª≠ l√Ω theo batch
    const RETRY_DELAY = 2000; // Delay 2s gi·ªØa c√°c retry
    const REQUEST_DELAY = 500; // Delay 500ms gi·ªØa m·ªói request

    // Cache v√† state management
    let isLoading = false;
    let shouldPause = false;
    let loadedSegments = 0;
    let startTime = 0;
    let totalDownloaded = 0;
    
    // Elements
    const elements = {
      log: document.getElementById("log"),
      video: document.getElementById("player"),
      progressFill: document.getElementById("progressFill"),
      progressText: document.getElementById("progressText"),
      speedText: document.getElementById("speedText"),
      timeText: document.getElementById("timeText"),
      sizeText: document.getElementById("sizeText"),
      loadBtn: document.getElementById("loadBtn"),
      pauseBtn: document.getElementById("pauseBtn"),
      resumeBtn: document.getElementById("resumeBtn"),
      clearBtn: document.getElementById("clearBtn")
    };

    // Logging v·ªõi timestamp
    function log(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = `[${timestamp}] ${message}`;
      elements.log.innerHTML += logEntry + '\n';
      elements.log.scrollTop = elements.log.scrollHeight;
      console.log(logEntry);
    }

    // C·∫≠p nh·∫≠t progress
    function updateProgress() {
      const progress = (loadedSegments / TOTAL_SEGMENTS) * 100;
      elements.progressFill.style.width = progress + '%';
      elements.progressText.textContent = `${loadedSegments}/${TOTAL_SEGMENTS}`;
      
      // T√≠nh t·ªëc ƒë·ªô
      const elapsed = (Date.now() - startTime) / 1000;
      const speed = elapsed > 0 ? (totalDownloaded / elapsed / 1024 / 1024).toFixed(2) : 0;
      elements.speedText.textContent = `${speed} MB/s`;
      
      // Th·ªùi gian ƒë√£ tr√¥i qua
      const minutes = Math.floor(elapsed / 60);
      const seconds = Math.floor(elapsed % 60);
      elements.timeText.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
      
      // Dung l∆∞·ª£ng
      elements.sizeText.textContent = `${(totalDownloaded / 1024 / 1024).toFixed(2)} MB`;
    }

    // T·∫£i header v·ªõi retry
    async function loadHeader() {
      for (let retry = 0; retry < 3; retry++) {
        try {
          log(`üì• T·∫£i header... (l·∫ßn th·ª≠ ${retry + 1})`);
          const response = await fetch(BASE_URL + HEADER_FILE);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const buffer = await response.arrayBuffer();
          log(`‚úÖ Header t·∫£i th√†nh c√¥ng (${buffer.byteLength} bytes)`);
          return buffer;
        } catch (error) {
          log(`‚ùå L·ªói t·∫£i header (l·∫ßn ${retry + 1}): ${error.message}`, 'error');
          if (retry === 2) throw error;
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
    }

    // T·∫£i segment v·ªõi retry v√† timeout
    async function downloadSegment(index, headerSize, retryCount = 0) {
      const filename = `out${index.toString().padStart(3, '0')}.png`;
      const maxRetries = 5; // TƒÉng s·ªë l·∫ßn retry
      
      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 20000); // TƒÉng timeout l√™n 20s

        try {
          // Th√™m delay gi·ªØa c√°c retry v√† request
          if (attempt > 0) {
            const delay = RETRY_DELAY * (attempt + 1); // Delay tƒÉng d·∫ßn: 2s, 4s, 6s, 8s, 10s
            await new Promise(resolve => setTimeout(resolve, delay));
            log(`üîÑ Th·ª≠ l·∫°i ${filename} (l·∫ßn ${attempt + 1}/${maxRetries + 1}) - ƒë·ª£i ${delay/1000}s`);
          } else {
            // Delay c∆° b·∫£n cho m·ªói request
            await new Promise(resolve => setTimeout(resolve, REQUEST_DELAY));
          }

          const response = await fetch(BASE_URL + filename, {
            signal: controller.signal,
            headers: {
              'Cache-Control': 'no-cache',
              'Pragma': 'no-cache',
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
          });
          
          clearTimeout(timeoutId);
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          
          const buffer = await response.arrayBuffer();
          
          // Ki·ªÉm tra k√≠ch th∆∞·ªõc file
          if (buffer.byteLength <= headerSize) {
            throw new Error(`File qu√° nh·ªè (${buffer.byteLength} bytes)`);
          }
          
          const tsData = buffer.slice(headerSize);
          
          totalDownloaded += buffer.byteLength;
          loadedSegments++;
          
          log(`‚úÖ T·∫£i th√†nh c√¥ng ${filename} (${(buffer.byteLength/1024).toFixed(1)}KB)`);
          return new Uint8Array(tsData);
          
        } catch (error) {
          clearTimeout(timeoutId);
          
          if (attempt === maxRetries) {
            throw new Error(`${filename}: ${error.message} (sau ${maxRetries + 1} l·∫ßn th·ª≠)`);
          }
          
          // Log retry v·ªõi chi ti·∫øt h∆°n
          log(`‚ö†Ô∏è L·ªói ${filename} (l·∫ßn ${attempt + 1}): ${error.message}`, 'warning');
        }
      }
    }

    // T·∫£i segments theo batch v·ªõi concurrency limit
    async function downloadSegmentsBatch(headerSize) {
      const segments = new Array(TOTAL_SEGMENTS).fill(null);
      let currentIndex = 0;
      let activeDownloads = 0;
      const maxActive = MAX_CONCURRENT;
      let successCount = 0;
      
      return new Promise((resolve) => {
        async function processNext() {
          if (shouldPause) {
            log('‚è∏Ô∏è T·∫£i ƒë√£ b·ªã t·∫°m d·ª´ng');
            return;
          }
          
          if (currentIndex >= TOTAL_SEGMENTS) {
            // ƒê·ª£i c√°c downloads c√≤n l·∫°i ho√†n th√†nh
            if (activeDownloads === 0) {
              log(`üéØ Ho√†n th√†nh t·∫£i ${successCount}/${TOTAL_SEGMENTS} segments`);
              resolve(segments.filter(seg => seg !== null));
            }
            return;
          }
          
          const index = currentIndex++;
          activeDownloads++;
          
          try {
            const segment = await downloadSegment(index, headerSize);
            segments[index] = segment;
            successCount++;
            updateProgress();
          } catch (error) {
            log(`‚ùå Kh√¥ng th·ªÉ t·∫£i segment ${index}: ${error.message}`, 'error');
            // V·∫´n tƒÉng loadedSegments ƒë·ªÉ kh√¥ng b·ªã stuck
            loadedSegments++;
            updateProgress();
          }
          
          activeDownloads--;
          
          // Th√™m delay l·ªõn h∆°n gi·ªØa c√°c batch
          const nextDelay = Math.min(activeDownloads * 200 + 300, 1000); // 300ms - 1s t√πy theo load
          setTimeout(processNext, nextDelay);
          
          // N·∫øu c√≤n slot tr·ªëng, b·∫Øt ƒë·∫ßu download kh√°c (v·ªõi delay)
          if (activeDownloads < maxActive && currentIndex < TOTAL_SEGMENTS) {
            setTimeout(processNext, nextDelay + 200);
          }
          
          // Ki·ªÉm tra xem ƒë√£ ho√†n th√†nh ch∆∞a
          if (currentIndex >= TOTAL_SEGMENTS && activeDownloads === 0) {
            log(`üéØ Ho√†n th√†nh t·∫£i ${successCount}/${TOTAL_SEGMENTS} segments`);
            resolve(segments.filter(seg => seg !== null));
          }
        }
        
        // Kh·ªüi ƒë·ªông c√°c workers ban ƒë·∫ßu v·ªõi delay l·ªõn
        for (let i = 0; i < Math.min(maxActive, TOTAL_SEGMENTS); i++) {
          setTimeout(() => processNext(), i * 1000); // 1s delay gi·ªØa c√°c worker
        }
      });
    }

    // Gh√©p segments th√†nh TS
    function combineSegments(segments) {
      log('üîó ƒêang gh√©p c√°c segments...');
      const totalLength = segments.reduce((sum, seg) => sum + seg.length, 0);
      const combined = new Uint8Array(totalLength);
      
      let offset = 0;
      for (const segment of segments) {
        combined.set(segment, offset);
        offset += segment.length;
      }
      
      log(`‚úÖ Gh√©p ho√†n th√†nh: ${(totalLength / 1024 / 1024).toFixed(2)} MB`);
      return combined;
    }

    // Convert TS to MP4
    async function convertToMP4(tsData) {
      log('üß† ƒêang load ffmpeg...');
      
      if (!ffmpeg.isLoaded()) {
        await ffmpeg.load();
      }
      
      log('üìù Ghi file input.ts v√†o FS ·∫£o...');
      ffmpeg.FS('writeFile', 'input.ts', tsData);
      
      log('üîÑ Chuy·ªÉn TS ‚Üí MP4...');
      await ffmpeg.run(
        '-i', 'input.ts',
        '-c:v', 'copy',
        '-c:a', 'aac',
        '-bsf:a', 'aac_adtstoasc',
        '-f', 'mp4',
        '-movflags', 'frag_keyframe+empty_moov',
        'output.mp4'
      );
      
      log('üì§ ƒê·ªçc file output.mp4');
      const mp4Data = ffmpeg.FS('readFile', 'output.mp4');
      
      // D·ªçn d·∫πp
      ffmpeg.FS('unlink', 'input.ts');
      ffmpeg.FS('unlink', 'output.mp4');
      
      return mp4Data;
    }

    // Main loading function
    async function loadVideo() {
      if (isLoading) return;
      
      isLoading = true;
      shouldPause = false;
      loadedSegments = 0;
      totalDownloaded = 0;
      startTime = Date.now();
      
      elements.loadBtn.disabled = true;
      elements.pauseBtn.disabled = false;
      elements.resumeBtn.disabled = true;
      elements.video.style.display = 'none';
      
      try {
        // Load header
        const headerBuffer = await loadHeader();
        const headerSize = headerBuffer.byteLength;
        
        // Load segments
        log('üì¶ B·∫Øt ƒë·∫ßu t·∫£i segments...');
        const segments = await downloadSegmentsBatch(headerSize);
        
        if (shouldPause) {
          log('‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng');
          return;
        }
        
        // Combine segments
        const combinedTS = combineSegments(segments);
        
        // Convert to MP4
        const mp4Data = await convertToMP4(combinedTS);
        
        // Create video URL
        const blob = new Blob([mp4Data.buffer], { type: 'video/mp4' });
        const url = URL.createObjectURL(blob);
        
        elements.video.src = url;
        elements.video.style.display = 'block';
        
        log('‚úÖ Video ƒë√£ s·∫µn s√†ng ƒë·ªÉ ph√°t!');
        
      } catch (error) {
        log(`‚ùå L·ªói: ${error.message}`, 'error');
      } finally {
        isLoading = false;
        elements.loadBtn.disabled = false;
        elements.pauseBtn.disabled = true;
        elements.resumeBtn.disabled = true;
      }
    }

    // Event listeners
    elements.loadBtn.addEventListener('click', loadVideo);
    
    elements.pauseBtn.addEventListener('click', () => {
      shouldPause = true;
      elements.pauseBtn.disabled = true;
      elements.resumeBtn.disabled = false;
      log('‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng t·∫£i');
    });
    
    elements.resumeBtn.addEventListener('click', () => {
      shouldPause = false;
      elements.pauseBtn.disabled = false;
      elements.resumeBtn.disabled = true;
      log('‚ñ∂Ô∏è Ti·∫øp t·ª•c t·∫£i');
    });
    
    elements.clearBtn.addEventListener('click', () => {
      // Reset t·∫•t c·∫£
      elements.video.src = '';
      elements.video.style.display = 'none';
      elements.log.innerHTML = 'üìã ƒê√£ x√≥a cache v√† reset...\n';
      elements.progressFill.style.width = '0%';
      elements.progressText.textContent = '0/0';
      elements.speedText.textContent = '0 MB/s';
      elements.timeText.textContent = '--:--';
      elements.sizeText.textContent = '0 MB';
      
      // Clear URL objects
      if (elements.video.src) {
        URL.revokeObjectURL(elements.video.src);
      }
    });

    // T·ª± ƒë·ªông b·∫Øt ƒë·∫ßu ki·ªÉm tra k·∫øt n·ªëi
    async function checkConnection() {
      try {
        log('üîç Ki·ªÉm tra k·∫øt n·ªëi ƒë·∫øn server...');
        const response = await fetch(BASE_URL + HEADER_FILE, { 
          method: 'HEAD',
          cache: 'no-cache'
        });
        
        if (response.ok) {
          log('‚úÖ K·∫øt n·ªëi server th√†nh c√¥ng!');
          log('üöÄ S·∫µn s√†ng t·∫£i video. Nh·∫•n "T·∫£i Video" ƒë·ªÉ b·∫Øt ƒë·∫ßu.');
        } else {
          log('‚ö†Ô∏è Server ph·∫£n h·ªìi kh√¥ng ·ªïn ƒë·ªãnh. C√≥ th·ªÉ g·∫∑p l·ªói khi t·∫£i.');
        }
      } catch (error) {
        log('‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server. Ki·ªÉm tra internet ho·∫∑c server c√≥ th·ªÉ ƒëang b·∫£o tr√¨.');
        log(`Chi ti·∫øt l·ªói: ${error.message}`);
      }
    }

    // Ch·∫°y ki·ªÉm tra k·∫øt n·ªëi khi load trang
    checkConnection();
  </script>
</body>
</html>
